@Oveverridng if we remove form the code it not give the but com


@Override is an annotation, not a keyword.

It is optional, meaning the code will still compile and run without it.

Why itâ€™s useful:

Helps the compiler check that you are actually overriding a method from a superclass or interface.

Catches typos or signature mismatches early.



Overriding
If we want to achieve the run time polymorphism then we have to use method
overriding.
Method overriding means declaring 2 methods with same method signature in 2
different classes which are having IS-A relation.
While Method overriding and writing the method signature, we must follow
following rules.
â€¢ Method name must be same
â€¢ List of parameters must be same
â€¢ Return type must be same
â€¢ Private, final and static methods cannot be overridden.
â€¢ There must be an IS-A relationship between classes (inheritance)




///////////////////////////////////////////////////////////////////////////

Run time Polymorphism
#)What is Method Overriding in Java?

Method overriding happens when a child class provides a new implementation of a method that is already defined in its parent class.
The method signature must be the same (name + parameters).
Return type must be same or covariant (subclass type).
It is an example of runtime polymorphism.


ðŸ”¹ Rules for Method Overriding
The method in the child class must have the same name and parameters as the parent.
Access modifier in child cannot be more restrictive than the parent.
final and static methods cannot be overridden.
You can call the parent method using super.methodName().




class Vehicle{
    void start(){
        System.out.println("vehicle is starting");
    }
}
class Car extends  Vehicle{
    @Override
    void start(){
        System.out.println("Car is startnig");
    }
}



public class MethodOverriding {
    public static void main(String[] args) {
        Vehicle v = new Vehicle();
        v.start(); // Vehicle is starting

        Vehicle c  = new Car(); //car is starting ->ovveridne  method//here parent method  ovverding  hai 
        c.start();
    }


}


public class MethodOverriding {
    // public static void main(String[] args) {
    //     Vehicle v = new Vehicle();
    //     v.start(); // Vehicle is starting

        Vehicle c  = new Car(); //car is starting -> overridden method
        c.start();   //not work
    // }
}


////////////////////////////////////
#)Overrding
if we want to  achieve the run time polymorphism then we have to use
ISA relationship means it  is inheritance .
RUle
Method name musr be smae
parameter must be same
return type must be same
private final ,static method cannot be ovveriden
These must be an IS-A between the classes

if hmre parent class me jo functionality hai ussi ko hm child class me use krna chate then fine we can  go with  that implemntaion with overriden

In case of method overridng if we don;t like parent imoplmention  we want to change in  
 the implemtion in child css we an do with ovverdring and  change the implmetaion



// Online Java Compiler
// Use this editor to write, compile and run your Java code online

  class Shape{
      
      void  draw(){
          System.out.println("Drwaing the shape");
      }
  }
  //here parent ki implmentiaon pasnd nhi ilsiye khud ki implmnetioan likh diya
 //basically ovveride kr ke hm khud ka implmnetiona de skt ahai
  
  class Circle extends Shape{
      //here parent ki implmentiaon pasnd nhi ilsiye khud ki implmnetioan likh diya
      @Override
      void draw(){
          System.out.println("Drwaing the circle");
      }
  }
  class Rect extends Circle{
      @Override
      void draw(){
          System.out.println("Drwaing the rect");
      }
  }

class Main {
    public static void main(String[] args) {
        Shape sh1=new Shape();
        sh1.draw();
        Circle c1 =new Circle();
        c1.draw();
        Rect rc =new Rect();
        rc.draw();
        
        //parent  chuld refenrce  hold kr skta hai
        Shape sh2 =new  Circle();  //this is called   run time
        //at run time it decide
        sh2.draw();
        
      
    }
    
}