#)What is Stream?

->strema is an interface represtn in java.util.stream.
-> Stream is as pipline throught which  our collection elements passes thorugh.
->Wjile element passes through it perform various operation like  sorting ,filtering  ,etc.
-> usefull when deals  with bulk processing  (Can do parallel processing).




#)Why stream api is required?
âž¡ Less code
âž¡ More readable
âž¡ No extra variables
---------------------------------------------------
Stream API is required to process collections in a faster, cleaner, 
and more readable way using functional programming

without stream
we need manuallu run the lop and add if condiotn
import java.util.*;

class Main {
    public static void main(String[] args) {
        
        List<Integer> list = Arrays.asList(2, 3, 4);
        
        List<Integer> even = new ArrayList<>();
        
        for (int i : list) {
            if (i % 2 == 0) {
                even.add(i);
            }
        }
        
        System.out.println(even); // Output: [2, 4]
    }
}


With Stream:
import java.util.*;

class Main {
    public static void main(String[] args) {
        
        List<Integer>list =Arrays.asList(2,3,4);
        List<Integer>even =list.stream()
        .filter(i -> i%2 ==0)
        .toList();
        
        System.out.println(even);
        
    }
}


--------------------------------------------------------------
What are Intermediate Operations in Streams?

#)Intermediate operations transform the stream and return another Stream.
They are lazy â€” they do NOT execute until a terminal operation is called.

Examples of Terminal + Intermediate operations
list.stream()            // source
    .filter(i -> i%2==0) // intermediate (lazy)
    .map(i -> i*2)       // intermediate
    .forEach(System.out::println); // terminal (executes the pipeline)


------------------------------------------------------
ðŸ§© Examples:

Operation	Description
filter(Predicate)	Filters elements based on a condition
map(Function)	Transforms elements
sorted()	Sorts elements
distinct()	Removes duplicates
limit(n)	Takes first n elements
skip(n)	Skips first n elements
peek(Consumer)	Used for debugging/logging



---------------------------------------------------------------------
#)What are Terminal Operations in Streams?
A terminal operation is the final operation in a Stream pipeline that produces the result and closes the stream. 
Examples: forEach(), toList(), collect(), count(), reduce(), max(), min(), findFirst().

ðŸ§© Examples:

Operation	Description
forEach(Consumer)	Performs action on each element
collect(Collector)	Converts stream to list, set, etc.
count()	Counts elements
reduce()	Combines elements to a single value
findFirst()	Returns the first element
allMatch(), anyMatch()	Test conditions on elements
----------------


#)Highlight key benefits you experienced
Reduced boilerplate loops (for, while).
Easier to read and maintain.
Can process large data in parallel using parallelStream() for better performance.



#)Different Way to create Stream

1) Form Collection

List<Integer>salaryList =Arrays.asList(3000,4100,9000);
Stream<Integer>streamFromIntegerArray=salaryList.stream();


2.From Array

Integer[] salaryArray ={3000,4100,1000,3500}
Stream<Integer>streamFromIntegerArray=Arrays.stream(salaryStream);

3)From Stream Method
Stream<Integer>streamFromIntegerArray=Stream.of(1000,2000,3000);


4)From Stream Builder

Stream.Builder<Integer>streamBuilder =Stream.builder();



5) From Stream Iterate
Stream<Integer>streamFromInterate =Stream.iterate()




///////////////////////////////////////////////////////////////
#)Intermediate OPeration

#)Why Streams are called lazy in Java
Intermediate operations donâ€™t execute immediately
Operations like map(), filter(), distinct(), sorted() just build up a pipeline.
They donâ€™t process elements until a terminal operation (collect(), forEach(), reduce(), etc.) is called.

Java Streams are lazy because intermediate operations do not execute immediately.
 They only build a pipeline, and execution happens when a terminal operation is invoked. 
 This allows optimization (like short-circuiting with limit, findFirst) and makes working with large or infinite data possible.



import java.util.Arrays;
import java.util.List;

public class LazyExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Create a stream and add a filter
        numbers.stream()
               .filter(n -> {
                   System.out.println("Checking " + n);
                   return n % 2 == 0;
               })
               // Terminal operation triggers processing
               .forEach(n -> System.out.println("Even number: " + n));
    }
}


//////////////////////////////////////////////////////



#0What are terminal Operation?

#)ForEach
Perform action on each element of the Stream ,.Do not return value

#)toArray()
Collect the element of the stream into an Array.
List<Integer>numbers =Arrays.asList(2,1,4,7,10);
#)reduce
#)Collect
#Min

----------------------------------------------------------------------
#)How many times we can use a single stream?
One terminal Operation is used on a stream ,it is closed /consumed and can not be used again for another terminal operation
Stream has already operated

----------------------------------------------------------------------
#)Parallel Stream
Parallel stream uses multiple threads
Main thread is NOT doing all the work


Main(){
List<Integer>numbers =Arrays.asList(11,22,33,44,55,66);
  
long sequenceProcessingStream =System.currentTimeMillis();
numbers.stream()
.map((Integer val) -> System.out.println(val));
System.out.println()

}

//paraller Processing

Helps to perform stream concurrently taking advantage of multi core cpu ParallelStream() method is used of regular stream() method.


Main(){
List<Integer>numbers =Arrays.asList(11,22,33,44,55,66);
  
long parallelProcessingStream =System.currentTimeMillis();
numbers.parallelStream()
.map((Integer val) -> val*val);
.forEach((Integer val)->System.out.println(var));
System.out.println()

}


in case of parallel numbers.parallelStream need to do.

#)Task Splitting : It uses "SPLITERATOR" function to split  the data into multiple chunks.
#)Task submission and parallel processing :Used Fork join pool technique
Fork means divide  and then join.











`























