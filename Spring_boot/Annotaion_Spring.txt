Serilization: Convert java object to json.
deserilization : Convert json  to java object.


1)Annotaion for configurations
2)Annotaion for data supply or injection
3)Annotaion for bean life cycle.
4)Miscallaneous annotations.




------------------------------
Anotiaons for configuraitons

These annotations configure java classes as spring bean ,enable ioc  conateinr
to manage bean life  cycle idea behind using these annotation is  to give instrucftion to framweowkr or container.

1)@Component: mark java class as spring bean.
2)@Service:  Similar to @Component, but  use for service classes(Business logic).
3)@Respositoty: mark java class as a DAO(Data access object). 
4)@Controller :mark java class a  web controller.
 5)@RestController:@Controller + @ResponseBody
6)@Configuraiton: define a  configuration class where  we can declare beans using   @Bean 
7)@Bean: mark method that return an object  to managed by SB.



Note :for custom class we can use @Componenet and get its bean but for  predefined class we cannot use


2)Annotaion for data supply and injection
These annotation used to inject data or object.
1)  @Autowired   :(By default  @Autowired perform injection byType but u can change byName)
2) @Value:   
3) Qualifier(Jiska Bean ka  naam diya hu sirf vhi a rha hai)
Qualiefier  we can use byName DI hota hai
4) @Primary () (class and method pe lg skta hai)
class ke bean ko primary mark krte hai 


@Compoent (class me  lga skte hai (@Target(ELment.Type)))



////////////////////////////////////////////////////////////

SpringFrameowrk -----------------> Dusra Frameowrk

java+ Framework   


Spring 
  



@Autowire  = @Inject
@Component = @Normal
@Qualifier = @Resources






#)Bean Life Cycle
@PostContructor
@PreDestroy


Misceanllous
@Lazy
@Scope
@ComponentScan
@PropertySource




Adavantage of Spring Boot

1)No Beans xml based configuration
2)Embed server
3)Auto Configuration
4)Rich annotations

spring-boot-starter-parent





@SpringBootApplication annotation 
is called main  class.


spring boot is equal to following notation
sprintbootConfiguration
SpringableAutoConfiguraiton
ComponentScan


---------------------------------------------------------------
@ConponentScan:
@ComponentScan tells Spring where to search for beans.
Spring needs to know which packages to scan and create objects from.
Thatâ€™s what @ComponentScan does.

#)â€œ@ComponentScan tells Spring which packages to scan for annotated components like @Component, @Service, @Repository, and @Controller.
 It is used when our beans are located outside the package of the main Spring Boot application.
  By default, Spring scans the package of the main class and all its sub-packages


-------------------------------------------------------------
When you create a Spring Boot app:

com.myapp
 â””â”€â”€ MyAppApplication (main class)
       @SpringBootApplication


And you keep all classes inside:

com.myapp.controllers
com.myapp.services
com.myapp.repository


#)Spring automatically scans everything inside the same package and sub-packages as the main class.

âœ… Because @SpringBootApplication already includes @ComponentScan.


-----------------------------------------------------
âœ… So when do we use @ComponentScan manually?

You only need it when:

âœ… Your beans are in a different package
âœ… Spring is not scanning that package automatically

---------------------------------------------------------
Example: When @ComponentScan is required

Directory:

com.mainapp
 â””â”€â”€ MainApp.java

com.services
 â””â”€â”€ EmailService.java


EmailService is in a different package.

Spring wonâ€™t find it automatically.

âœ… You need:

@SpringBootApplication
@ComponentScan(basePackages = "com.services")
public class MainApp {}


This tells Spring:

ðŸ‘‰ â€œScan com.services package and create beans from there.â€


--------------------------------------------------------------
#)How does spirng know where to search for scompoents or beans?


-----------------------------------------------------------------------------------
#)@Autowired is used to automatically inject one Spring bean into another.
Spring sees the annotation and gives you the required dependency without you creating it manually.
It removes the need for new and lets Spring manage object creation and lifecycle.
#)This improves loose coupling, testability, and clean code.â€
---------------------------------------------------------------------------------------
Why do we use @Autowired? (Interview strong points)

Automatic Dependency Injection
Spring manages object creation; we donâ€™t use new.

Loose Coupling
Classes depend on interfaces, not implementations.

Easier Testing
You can easily mock dependencies.

Cleaner, more maintainable code
-------------------------------------------------------------------------------
#)Types of Autowiring 

1)By Type (most common)
2)By Name
3)Constructor Injection
4)Field Injection
5)Setter Injection
----------------------------------------------------------------------
â€œAlthough @Autowired can be used on fields, the recommended way is constructor 
injection because it makes code cleaner, testable, and avoids reflection.â€

Example:
@Service
public class OrderService {

    private final PaymentService paymentService;

    @Autowired
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}
------------------------------------------------------------

1. Autowiring By Type (MOST COMMON)

Spring looks for a bean based on class type.

âœ… Example
@Service
public class PaymentService {}

@Service
public class OrderService {

    @Autowired   // injects bean of type PaymentService
    private PaymentService paymentService;
}


âœ… Works because only one PaymentService bean exists.
âŒ If two beans have same type â†’ ambiguity.

âœ… Most commonly used autowiring mechanism.

âœ… 2. Autowiring By Name

Spring injects the bean whose name matches the variable name.

âœ… Example
@Service("paypalService")
public class PaypalPaymentService implements PaymentService {}

@Service
public class OrderService {

    @Autowired
    private PaymentService paypalService; // variable name matches bean name
}


âœ… Works only because variable name = bean name
âŒ Not recommended â€” too fragile, depends on variable naming

âœ… 3. Constructor Injection (RECOMMENDED)

Spring injects dependency through constructor.

âœ… Example
@Service
public class OrderService {

    private final PaymentService paymentService;

    @Autowired
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


âœ… Best practice
âœ… Mandatory dependency
âœ… Easy for unit testing
âœ… Supports immutability
âœ… Works without @Autowired if only one constructor exists in the class

Used in real projects? â†’ YES âœ” (recommended by industry)

âœ… 4. Field Injection

Uses @Autowired directly on fields.

âœ… Example
@Service
public class OrderService {

    @Autowired
    private PaymentService paymentService;
}


âœ… Simple
âŒ Not recommended
âŒ Hard to unit test
âŒ Uses reflection
âŒ Cannot mark fields as final

Used in real projects? â†’ Sometimes, but NOT a good practice

âœ… 5. Setter Injection

Dependency is injected through setter method.

âœ… Example
@Service
public class OrderService {

    private PaymentService paymentService;

    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


âœ… Optional dependencies
âœ… Useful when dependency can change
âŒ Not ideal for required dependencies

-------------------------------------------------------------------
@Qualifier â†’ tells which bean to inject when multiple beans exist


---------------------------------------------------------------------------------
#)What is @Component?
@Component is a Spring annotation used to mark a class as a Spring-managed bean.
When you annotate a class with @Component, Springâ€™s component scan will automatically:

âœ… Detect the class
âœ… Create its object
âœ… Store it in the IoC container
âœ… Allow it to be injected using @Autowired

---------------------------------------------------------------------------
âœ… Simple example
@Component
public class EmailUtil {
    public void sendEmail() {
        System.out.println("Sending email...");
    }
}


Then you can inject it anywhere:

@Service
public class UserService {

    @Autowired
    private EmailUtil emailUtil;
}


âœ… No need to write new EmailUtil()
âœ… Spring does the creation and injection
--------------------------------------------------------------------
âœ… Why do we use @Component? (Interview answer)
â€œWe use @Component to let Spring automatically detect and manage classes as beans.
It enables dependency injection and removes manual object creation.â€


---------------------------------------------------------------------------

#)What is @Bean?
@Bean is used inside a @Configuration class to manually create and register a Spring bean.
It is commonly used for third-party classes or when you need full control over object creation.

------------------------------------------------------------------------------
#)When to use @Bean?
You use @Bean when:
âœ… 1. You want to register objects from third-party libraries


@Configuration
public class SecurityConfig {

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();    // used for password hashing
    }
}
---------------------------------------------------------------------
How it works internally? (Strong answer)

Spring uses CGLIB proxies to ensure:

Beans inside @Configuration are singleton

@Bean methods are executed only once

Example:
------------------------------------------------------------------
@Configuraiton
â€œWe use @Configuration when we want to define beans manually.
It allows Spring to treat the class as a source of bean definitions.
This is useful for third-party objects, custom initialization, or configuration logic.â€
----------------------------------------------------------------
#)@Repository
@Repository marks a class as the database layer.
Spring automatically creates it as a bean and handles SQL exceptions for us.â€
@Repository (Database Layer)

â€œ@Repository is used for classes that interact with the database.
It also converts SQL exceptions into Spring exceptions.â€

Example:
@Repository
public class UserRepository {}


Used for:
âœ… Database queries
âœ… JDBC, JPA, Hibernate operations
âœ… DAO layer


------------------------------------------------
#)âœ… What is @Service? (Simple Answer)
#)â€œ@Service is used to mark a class that contains business logic.
It tells Spring to create an object of that class and manage it as a bean.â€
#)Spring automatically creates and manages it as a bean so it can be injected using @Autowired.â€

------------------------------------------------------------------
#)Controller
â€œ@Controller is used to create web controllers that return HTML views using Spring MVC.â€

#)âœ… When NOT to use @Controller?
âŒ When building REST APIs
âœ… Use @RestController instead (returns JSON)
--------------------------------------------------------------------

-->@SpringBootConfiguration ->we can configuration bean
-->@EnableAutoConfiguration:

#)What is AutoConfiguration in Spring Boot?
AutoConfiguration means Spring Boot automatically configures your application based on the dependencies present in your classpath.
You do NOT need to write manual configuration for common features.


#)What is Classpath? (Simple Answer)
Classpath is the path where Java looks for your .class files and required libraries (JAR files) to run your application.
It tells Java where to find the classes needed to compile and run the program.

#)

































































