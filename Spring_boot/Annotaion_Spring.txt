
what is annotaion?
#)annotaion is jave is the metadata start with(@)give that provide additional information  to the compiler.
#)Annotations help remove boilerplate code and make configuration easier, cleaner, and more readable.
#)We use annotations to simplify configuration.
Instead of writing long XML or configuration classes, annotations let us declaratively define:

-----------------------------------------------------------------------------------------

#)If interviewer asks: Give examples of annotations you used.
Perfect examples:

@RestController ‚Äì marks class as REST API controller
@Service ‚Äì marks a service/business layer
@Autowired ‚Äì dependency injection
@GetMapping/@PostMapping ‚Äì map HTTP requests
@Entity ‚Äì mark a class as a JPA entity
@NotBlank/@Email/@Valid ‚Äì validation annotations
@RestControllerAdvice ‚Äì global exception handling
-------------------------------------------------------------------------------------

üü¶ ‚≠ê If interviewer asks: How do annotations work internally?

Say this:

‚ÄúAnnotations are processed by reflection.
Spring reads annotations at runtime, registers beans, maps endpoints, validates input, and applies cross-cutting features.
This replaces manual configuration.‚Äù


---------------------------------------------------------------------
the main applicaiton class is also bean  as its annotated with @Configuraiton which is a @Compoent

-----------------------------------------------------
Serilization: Convert java object to json.
deserilization : Convert json  to java object.

Note :for custom class we can use @Componenet and get its bean but for  predefined class we cannot use
@Compoent (class me  lga skte hai (@Target(ELment.Type)))



Note;
the main application class is also bean as its annotate with @Controller which is a @Compoent

-------------------------------------------------------------------------------
#)How spring boot starts?
‚ÄúSpring Boot starts by running the main class, which contains the main() method.
Inside that method, SpringApplication.run() is called.
This method creates the Spring application context, does component scanning, loads all beans, 
applies auto-configuration, and finally starts the embedded server like Tomcat.

----------------------------------------------------------------
#)what is ApplicationConext?
It creates and manages all beans and handles dependency injection.‚Äù 
it is simila  to  ioc container
-------------------------------------------------------------------------


1)@SpringBootApplication
we use @SpringBootApplication annotation launch our application

‚úÖ Tells Spring Boot to start the application
‚úÖ Tells Spring Boot to scan all components in that package
‚úÖ Performs auto-configuration
‚úÖ Starts the embedded server (Tomcat)

------------------------------------------------------------

---------------------------------------------------------------
#)This annotation combination  of three annotations
‚úÖ @SpringBootApplication = 3 Annotations
1)@SpringBootConfiguration ->we can configuration bean
2)@EnableAutoConfiguration
3)@ComponentScan
It tells Spring Boot to configure itself, scan components, and load beans automatically.‚Äù

---------------------------------------------------------------------
#)SpringBootConfiguration:
This class is used for Spring Boot configuration.
Why do we need it?

Because Spring needs to know:
üëâ ‚ÄúFrom which class should I start loading all the configurations and beans?‚Äù
So, it marks your main class as the configuration class

---------------------------------------------------------------------
1)@ConponentScan:
Spring scan a package and create object from that what @ComponentScan  does
or
Spring needs to know which packages to scan and create objects from.
That‚Äôs what @ComponentScan does.

#)‚Äú@ComponentScan tells Spring which packages to scan for annotated components like @Component, @Service, @Repository, and @Controller.
 #)It is used when our beans are located outside the package of the main Spring Boot application.
  By default, Spring scans the package of the main class and all its sub-packages

  here we want to check in package ke andar component  hai kya.
it is typically placed on the main class of the application.

-------------------------------------------------------------
@EnableAutoConfiguration:
Tells Spring Boot to automatically configure the application based on 
dependencies (e.g., if you add Spring Web, it auto-configures Tomcat).
ex: when we define  the spring-boot-starte-web dependencies in our classpath Spring boot auto-configuaration
Tomcat and spring MVC.



-------------------------------------------------------------------------
When you create a Spring Boot app:

com.myapp
 ‚îî‚îÄ‚îÄ MyAppApplication (main class)
       @SpringBootApplication


And you keep all classes inside:

com.myapp.controllers
com.myapp.services
com.myapp.repository

#)Spring automatically scans everything inside the same package and sub-packages as the main class.
‚úÖ Because @SpringBootApplication already includes @ComponentScan.

-----------------------------------------------------
‚úÖ So when do we use @ComponentScan manually?
You only need it when:
‚úÖ Your beans are in a different package then required as likhna else @SpringBootApplication ke andar sara hota hai
‚úÖ Spring is not scanning that package automatically

---------------------------------------------------------
Example: When @ComponentScan is required

Directory:

com.mainapp
 ‚îî‚îÄ‚îÄ MainApp.java

com.services
 ‚îî‚îÄ‚îÄ EmailService.java


EmailService is in a different package.

Spring won‚Äôt find it automatically.

‚úÖ You need:

@SpringBootApplication
@ComponentScan(basePackages = "com.services")
public class MainApp {}

This tells Spring:
üëâ ‚ÄúScan com.services package and create beans from there.‚Äù

--------------------------------------------------------------
#)How does spirng know where to search for compoents or beans?


-----------------------------------------------------------------------------------
#)@Autowired 
1)@Autowired is a Spring annotation used for automatic dependency injection.
2)Spring to automatically create and inject the required bean instead of manually creating it
It removes the need for new and lets Spring manage object creation and lifecycle.
3)This improves loose coupling, testability, and clean code.‚Äù
---------------------------------------------------------------------------------------
Why do we use @Autowired? (Interview strong points)

Automatic Dependency Injection
Spring manages object creation; we don‚Äôt use new.

Loose Coupling
Classes depend on interfaces, not implementations.

Easier Testing
You can easily mock dependencies.

Cleaner, more maintainable code


----------------------------------------------------
#)How does @Autowired work?
Spring has an IOC (Inversion of Control) Container that manages all beans.
When it sees @Autowired, it performs dependency injection in 
5 ways

-------------------------------------------------------------------------------
#)Types of Autowiring 

1)By Type (most common)
2)By Name
3)Constructor Injection
4)Field Injection
5)Setter Injection
----------------------------------------------------------------------
in‚ÄúAlthough @Autowired can be used on fields, the recommended way is constructor 
jection because it makes code cleaner, testable, and avoids reflection.‚Äù

Example:
@Service
public class OrderService {

    private final PaymentService paymentService;

    @Autowired
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
        
    }
}
------------------------------------------------------------

1. Autowiring By Type (MOST COMMON)

Spring looks for a bean based on class type.

‚úÖ Example
@Service
public class PaymentService {}

@Service
public class OrderService {

    @Autowired   // injects bean of type PaymentService
    private PaymentService paymentService;
}


‚úÖ Works because only one PaymentService bean exists.
‚ùå If two beans have same type ‚Üí ambiguity.

‚úÖ Most commonly used autowiring mechanism.

-----------------------------------------------------------------------------
‚úÖ 2. Autowiring By Name

Spring injects the bean whose name matches the variable name.

‚úÖ Example
@Service("paypalService")
public class PaypalPaymentService implements PaymentService {}

@Service
public class OrderService {

    @Autowired
    private PaymentService paypalService; // variable name matches bean name
}


‚úÖ Works only because variable name = bean name
‚ùå Not recommended ‚Äî too fragile, depends on variable naming

----------------------------------------------------------------------------
‚úÖ 3. Constructor Injection (RECOMMENDED)

Spring injects dependency through constructor.

‚úÖ Example
@Service
public class OrderService {

    private final PaymentService paymentService;

    @Autowired
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


‚úÖ Best practice
‚úÖ Mandatory dependency
‚úÖ Easy for unit testing
‚úÖ Supports immutability
‚úÖ Works without @Autowired if only one constructor exists in the class

Used in real projects? ‚Üí YES ‚úî (recommended by industry)

---------------------------------------------------------------------------------------

‚úÖ 4. Field Injection

Uses @Autowired directly on fields.

‚úÖ Example
@Service
public class OrderService {

    @Autowired
    private PaymentService paymentService;
}


‚úÖ Simple
‚ùå Not recommended
‚ùå Hard to unit test
‚ùå Uses reflection
‚ùå Cannot mark fields as final

Used in real projects? ‚Üí Sometimes, but NOT a good practice

‚úÖ 5. Setter Injection

Dependency is injected through setter method.

‚úÖ Example
@Service
public class OrderService {

    private PaymentService paymentService;

    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


‚úÖ Optional dependencies
‚úÖ Useful when dependency can change
‚ùå Not ideal for required dependencies

-------------------------------------------------------------------
#)‚Äú@Qualifier is used to specify exactly which bean should be injected 
when multiple beans of the same type exist.‚Äù


üü¶ Why do we need @Qualifier?
When there are multiple beans of the same class, Spring gets confused.

Example:
@Service
public class EmailService implements MessageService {}

@Service
public class SMSService implements MessageService {}


Now you inject:
@Autowired
MessageService messageService;


‚ùå Spring does NOT know which one to inject
(email or sms?) ‚Üí Ambiguity

This causes:
NoUniqueBeanDefinitionException

üü¢ Solution ‚Üí Use @Qualifier
@Autowired
@Qualifier("emailService")
MessageService messageService;


-----------------------------------------------------------------------------------
#)What is @Component?
1)@Component marks a class as a Spring-managed bean.
Spring automatically creates its object and handles dependency injection.‚Äù

‚ÄúWe use @Component to let Spring automatically detect and manage classes as beans.
It enables dependency injection and removes manual object creation.‚Äù

‚úÖ Detect the class
‚úÖ Create its object
‚úÖ Store it in the IoC container
‚úÖ Allow it to be injected using @Autowired

---------------------------------------------------------------------------
‚úÖ Simple example
@Component
public class EmailUtil {
    public void sendEmail() {
        System.out.println("Sending email...");
    }
}


Then you can inject it anywhere:

@Service
public class UserService {

    @Autowired
    private EmailUtil emailUtil;
}


‚úÖ No need to write new EmailUtil()
‚úÖ Spring does the creation and injection
--------------------------------------------------------------------
#)What is @Bean?
@Bean is used inside a @Configuration class to manually create and register a Spring bean.
It is commonly used for third-party classes or when you need full control over object creation.

------------------------------------------------------------------------------
#)When to use @Bean?
You use @Bean when:
‚úÖ 1. You want to register objects from third-party libraries


@Configuration
public class SecurityConfig {

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();    // used for password hashing
    }
}
---------------------------------------------------------------------
How it works internally? (Strong answer)

Spring uses CGLIB proxies to ensure:

Beans inside @Configuration are singleton

@Bean methods are executed only once

Example:
------------------------------------------------------------------
@Configuraiton
‚ÄúWe use @Configuration when we want to define beans manually.
It allows Spring to treat the class as a source of bean definitions.
This is useful for third-party objects, custom initialization, or configuration logic.‚Äù
----------------------------------------------------------------
#)@Repository
#)‚Äú@Repository is used for classes that interact with the database.
#)Spring automatically creates it as a bean and handles SQL exceptions for us.‚Äù
It also converts SQL exceptions into Spring exceptions.‚Äù
#)@Repository marks a class as the database layer.

@Repository (Database Layer)

Example:
@Repository
public class UserRepository {}

Used for:
‚úÖ Database queries
‚úÖ JDBC, JPA, Hibernate operations
‚úÖ DAO layer


------------------------------------------------
#)‚úÖ What is @Service? (Simple Answer)
#)‚Äú@Service is used to mark a class that contains business logic.
It tells Spring to create an object of that class and manage it as a bean.‚Äù
#)Spring automatically creates and manages it as a bean so it can be injected using @Autowired.‚Äù

------------------------------------------------------------------
#)Differnce between controller and RestController

#)Controller
@Controller is used to create web controllers that return HTML views using Spring MVC.‚Äù
@Controller is used to return view pages, not JSON."
@Controller is a Spring MVC annotation used to define 
a controller class that handles HTTP requests and returns a view (JSP/HTML/Thymeleaf template).

@RestController is used to build REST APIs, where the controller returns JSON or XML directly.

#)‚úÖ When NOT to use @Controller?
‚ùå When building REST APIs
‚úÖ Use @RestController instead (returns JSON)
--------------------------------------------------------------------

-->@SpringBootConfiguration ->we can configuration bean
-->@EnableAutoConfiguration:
------------------------------------------------------------------------------

#)What is AutoConfiguration in Spring Boot?
AutoConfiguration means Spring Boot automatically configures your
 application based on the dependencies present in your classpath.
You do NOT need to write manual configuration for common features.

-------------------------------------------------------------------------------
#)What is Classpath? (Simple Answer)
Classpath is the path where Java looks for your .class files and required libraries (JAR files) to run your application.
It tells Java where to find the classes needed to compile and run the program.

#)Why do we need @Component?
Because without it, Spring won‚Äôt know your class exist

----------------------------------------------------------------------------
@Value:
we red the value whatever written in app.properties
use the @Value annotaion to acces the properties which  isdefined in the applicaiton properties files
ex:
app.proerteis
app.name=My Spring App

@Service
public class AppService {

    @Value("${app.name}")
    private String appName;
    public void printValues() {
        System.out.println(appName);
        System.out.println(appVersion);
    }
}


Important: You CANNOT use @Value without a field/method/constructor parameter.

You must inject the value into:

‚úî a field
@Value("${app.name}")
private String appName;

‚úî OR a constructor parameter
public AppService(@Value("${app.name}") String appName) {
    this.appName = appName;
}

‚úî OR a method parameter
@Value("${app.name}")
public void setAppName(String appName) {
    this.appName = appName;
}

---------------------------------------------------------
For Doing Rest API
1)Need to  use this library spring-boo-starter-web

#)@RestController  
RestController is combianiton of two annotaion 
@Controller +@ResponseBody
is Spring Boot‚Äôs way to build REST APIs.
it returns json/text directly. 

--------------------------------------------------------------------
#)@RequestMapping ("/api") 
What is @RequestMapping in Spring Boot?
@RequestMapping is an annotation used to map HTTP requests (like GET, POST, PUT, DELETE)
 to specific methods or classes in a Spring MVC controller.
It tells Spring:
üëâ ‚ÄúWhen a request comes to this URL, call this method.‚Äù
-------------------------------------------------------------
Mapping Specific HTTP Methods
Usually, we don‚Äôt use @RequestMapping alone.
Instead, we use its shortcuts:

‚úî @GetMapping
‚úî @PostMapping
‚úî @PutMapping
‚úî @DeleteMapping
‚úî @PatchMapping
-----------------------------------------------
@GetMapping("/users")
public String getUsers() {
    return "All users";
}
This is exactly same as:

java
Copy code
@RequestMapping(value = "/users", method = RequestMethod.GET)
public String getUsers() {
    return "All users";
}



--------------------------------------
Request Handling Annotaions
#)@PathVariable ‚Äì Extract values from URL
Use
Fetching a specific resource
/users/15
/orders/100/items

URL: /cars/10

@GetMapping("/cars/{id}")
public Car getCar(@PathVariable int id) { }
-------------------------------------------------
@RequestParam ‚Äì Extract query params
Used to capture query parameters from URL after ?.

#)use
Passing filters
Sorting
Pagination
Optional values


URL: /cars?color=red&year=2020

@GetMapping("/cars")
public List<Car> filterCars(@RequestParam String color,
                            @RequestParam int year) {
}
-------------------------------------------------------------------------
‚úÖ 7. @PathVariable ‚Äì Extract values from URL

URL: /cars/10

@GetMapping("/cars/{id}")
public Car getCar(@PathVariable int id) { }
check this id shoudl be same wat if diffent


‚úÖ Extracts values from URL path

‚úÖ 8. @RequestParam ‚Äì Extract query params

URL: /cars?color=red&year=2020

@GetMapping("/cars")
public List<Car> filterCars(@RequestParam String color,
                            @RequestParam int year) {
}


‚úÖ For optional:

@RequestParam(required = false)
String brand
-----------------------------------------------------------
@RequestBody is used when we want to read JSON data from the request body and
 convert it into a Java object.
 
You want to receive JSON data from the client
‚úî Convert JSON ‚Üí Java Object automatically
----------------------------------------------------------------------------
@ResponseBody is used when we want to return data (like JSON)
 directly to the client instead of returning a view.

@RestController automatically applies @ResponseBody to all methods.



‚úÖ 9. @RequestBody ‚Äì Extract JSON from the request body
Map jsonBody to object
@PostMapping("/cars")
public Car createCar(@RequestBody Car car) { }


‚úÖ Spring auto-converts JSON ‚Üí Java Object
‚úÖ Uses Jackson

‚úÖ 10. @ResponseBody ‚Äì Return JSON response
@ResponseBody
@GetMapping("/message")
public String getMessage() {
    return "Hello";
}


‚úÖ Automatically done in @RestController
(No need to use @ResponseBody manually)
-----------------------
‚úÖ 11. @RestController ‚Äì Combines @Controller + @ResponseBody
@RestController
public class CarController { }


‚úÖ All methods return JSON
‚úÖ Most used for REST APIs

‚úÖ 12. @RequestHeader ‚Äì Read header values
@GetMapping("/cars")
public String checkHeader(@RequestHeader("User-Agent") String agent) {
    return agent;
}
--------------------------------------------------

‚úÖ 13. @CookieValue ‚Äì Read cookie values
@GetMapping("/user")
public String getCookie(@CookieValue("sessionId") String sessionId) {
    return sessionId;
}
--------------------------------------------------

Returint Response
Use ResponseBody to control status codes and headers


----------------------------------------------
#)input validation  validate in controller
Add dependecy -> spring-boot-starter-validation



----------------------------------------------------------------
#)@Profile
Profile
#)What is a Profile in Spring Boot? (Simple Answer)
A Profile in Spring Boot is a way to define different configurations for different environments ‚Äî like dev, test, stage, prod.
You activate one profile at a time depending on where your application is running.

#)How do you have diffenrt configuaration for differnt enviroments?
we need to define individula env for each Profile
->application-dev.properties
in application.properties,
spring.profiles.active=prod


------------------------------------
#)Why do we use Profiles?

Because each environment needs different:
‚úÖ Database URLs
‚úÖ API URLs
‚úÖ Logging levels
‚úÖ Credentials
‚úÖ Ports
‚úÖ Feature flags

Profiles help us separate these cleanly.
--------------------------------------
Common example

You might have:

application-dev.properties
application-test.properties
application-prod.properties

-----------------------------------------------------
Inside application-dev.properties:

server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/dev_db


Inside application-prod.properties:

server.port=8080
spring.datasource.url=jdbc:mysql://prod-server:3306/prod_db



‚úÖ Using @Profile annotation
You can activate beans only for specific environments:

@Service
@Profile("dev")
public class DevService {}

@Service
@Profile("prod")
public class ProdService {}


Only ONE of these will load based on active profile.


---------------------------------------------------------------------
#)@Primary :
If multiple beans of the same type exist, use this one by default.
tells Spring to use this bean as the default one when multiple beans of the same type exist."
When Spring finds two or more beans of the same type, it gets confused ‚Üí Ambiguity error.
To avoid this, we mark one bean as @Primary, so Spring chooses it automatically.

#0what is differnce between them?


---------------------------------------------
How to change the port?
server.port=9090
--------------------------------------------



#)@Transacional
@Transactional ensures that a group of database operations runs as one unit.
 If any operation fails, everything rolls back

@Service
public class UserService {

    @Transactional
    public void createUser() {
        userRepo.save(user);
        addressRepo.save(address);
        // If address save fails ‚Üí both roll back
    }
}


















































