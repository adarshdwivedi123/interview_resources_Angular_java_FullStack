Serilization: Convert java object to json.
deserilization : Convert json  to java object.


1)Annotaion for configurations
2)Annotaion for data supply or injection
3)Annotaion for bean life cycle.
4)Miscallaneous annotations.




------------------------------
Anotiaons for configuraitons

These annotations configure java classes as spring bean ,enable ioc  conateinr
to manage bean life  cycle idea behind using these annotation is  to give instrucftion to framweowkr or container.

1)@Component: mark java class as spring bean.
2)@Service:  Similar to @Component, but  use for service classes(Business logic).
3)@Respositoty: mark java class as a DAO(Data access object). 
4)@Controller :mark java class a  web controller.
 5)@RestController:@Controller + @ResponseBody
6)@Configuraiton: define a  configuration class where  we can declare beans using   @Bean 
7)@Bean: mark method that return an object  to managed by SB.



Note :for custom class we can use @Componenet and get its bean but for  predefined class we cannot use


2)Annotaion for data supply and injection
These annotation used to inject data or object.
1)  @Autowired   :(By default  @Autowired perform injection byType but u can change byName)
2) @Value:   
3) Qualifier(Jiska Bean ka  naam diya hu sirf vhi a rha hai)
Qualiefier  we can use byName DI hota hai
4) @Primary () (class and method pe lg skta hai)
class ke bean ko primary mark krte hai 


@Compoent (class me  lga skte hai (@Target(ELment.Type)))



////////////////////////////////////////////////////////////

SpringFrameowrk -----------------> Dusra Frameowrk

java+ Framework   


Spring 
  



@Autowire  = @Inject
@Component = @Normal
@Qualifier = @Resources






#)Bean Life Cycle
@PostContructor
@PreDestroy


Misceanllous
@Lazy
@Scope
@ComponentScan
@PropertySource




Adavantage of Spring Boot

1)No Beans xml based configuration
2)Embed server
3)Auto Configuration
4)Rich annotations

spring-boot-starter-parent





@SpringBootApplication annotation 
is called main  class.


spring boot is equal to following notation
sprintbootConfiguration
SpringableAutoConfiguraiton
ComponentScan


---------------------------------------------------------------
@ConponentScan:
@ComponentScan tells Spring where to search for beans.
Spring needs to know which packages to scan and create objects from.
That‚Äôs what @ComponentScan does.

#)‚Äú@ComponentScan tells Spring which packages to scan for annotated components like @Component, @Service, @Repository, and @Controller.
 It is used when our beans are located outside the package of the main Spring Boot application.
  By default, Spring scans the package of the main class and all its sub-packages


-------------------------------------------------------------
When you create a Spring Boot app:

com.myapp
 ‚îî‚îÄ‚îÄ MyAppApplication (main class)
       @SpringBootApplication


And you keep all classes inside:

com.myapp.controllers
com.myapp.services
com.myapp.repository


#)Spring automatically scans everything inside the same package and sub-packages as the main class.

‚úÖ Because @SpringBootApplication already includes @ComponentScan.


-----------------------------------------------------
‚úÖ So when do we use @ComponentScan manually?

You only need it when:

‚úÖ Your beans are in a different package
‚úÖ Spring is not scanning that package automatically

---------------------------------------------------------
Example: When @ComponentScan is required

Directory:

com.mainapp
 ‚îî‚îÄ‚îÄ MainApp.java

com.services
 ‚îî‚îÄ‚îÄ EmailService.java


EmailService is in a different package.

Spring won‚Äôt find it automatically.

‚úÖ You need:

@SpringBootApplication
@ComponentScan(basePackages = "com.services")
public class MainApp {}


This tells Spring:

üëâ ‚ÄúScan com.services package and create beans from there.‚Äù


--------------------------------------------------------------
#)How does spirng know where to search for scompoents or beans?


-----------------------------------------------------------------------------------
#)@Autowired is used to automatically inject one Spring bean into another.
Spring sees the annotation and gives you the required dependency without you creating it manually.
It removes the need for new and lets Spring manage object creation and lifecycle.
#)This improves loose coupling, testability, and clean code.‚Äù
---------------------------------------------------------------------------------------
Why do we use @Autowired? (Interview strong points)

Automatic Dependency Injection
Spring manages object creation; we don‚Äôt use new.

Loose Coupling
Classes depend on interfaces, not implementations.

Easier Testing
You can easily mock dependencies.

Cleaner, more maintainable code
-------------------------------------------------------------------------------
#)Types of Autowiring 

1)By Type (most common)
2)By Name
3)Constructor Injection
4)Field Injection
5)Setter Injection
----------------------------------------------------------------------
‚ÄúAlthough @Autowired can be used on fields, the recommended way is constructor 
injection because it makes code cleaner, testable, and avoids reflection.‚Äù

Example:
@Service
public class OrderService {

    private final PaymentService paymentService;

    @Autowired
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}
------------------------------------------------------------

1. Autowiring By Type (MOST COMMON)

Spring looks for a bean based on class type.

‚úÖ Example
@Service
public class PaymentService {}

@Service
public class OrderService {

    @Autowired   // injects bean of type PaymentService
    private PaymentService paymentService;
}


‚úÖ Works because only one PaymentService bean exists.
‚ùå If two beans have same type ‚Üí ambiguity.

‚úÖ Most commonly used autowiring mechanism.

‚úÖ 2. Autowiring By Name

Spring injects the bean whose name matches the variable name.

‚úÖ Example
@Service("paypalService")
public class PaypalPaymentService implements PaymentService {}

@Service
public class OrderService {

    @Autowired
    private PaymentService paypalService; // variable name matches bean name
}


‚úÖ Works only because variable name = bean name
‚ùå Not recommended ‚Äî too fragile, depends on variable naming

‚úÖ 3. Constructor Injection (RECOMMENDED)

Spring injects dependency through constructor.

‚úÖ Example
@Service
public class OrderService {

    private final PaymentService paymentService;

    @Autowired
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


‚úÖ Best practice
‚úÖ Mandatory dependency
‚úÖ Easy for unit testing
‚úÖ Supports immutability
‚úÖ Works without @Autowired if only one constructor exists in the class

Used in real projects? ‚Üí YES ‚úî (recommended by industry)

‚úÖ 4. Field Injection

Uses @Autowired directly on fields.

‚úÖ Example
@Service
public class OrderService {

    @Autowired
    private PaymentService paymentService;
}


‚úÖ Simple
‚ùå Not recommended
‚ùå Hard to unit test
‚ùå Uses reflection
‚ùå Cannot mark fields as final

Used in real projects? ‚Üí Sometimes, but NOT a good practice

‚úÖ 5. Setter Injection

Dependency is injected through setter method.

‚úÖ Example
@Service
public class OrderService {

    private PaymentService paymentService;

    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


‚úÖ Optional dependencies
‚úÖ Useful when dependency can change
‚ùå Not ideal for required dependencies

-------------------------------------------------------------------
@Qualifier ‚Üí tells which bean to inject when multiple beans exist


---------------------------------------------------------------------------------
#)What is @Component?
@Component is a Spring annotation used to mark a class as a Spring-managed bean.
When you annotate a class with @Component, Spring‚Äôs component scan will automatically:

‚úÖ Detect the class
‚úÖ Create its object
‚úÖ Store it in the IoC container
‚úÖ Allow it to be injected using @Autowired

---------------------------------------------------------------------------
‚úÖ Simple example
@Component
public class EmailUtil {
    public void sendEmail() {
        System.out.println("Sending email...");
    }
}


Then you can inject it anywhere:

@Service
public class UserService {

    @Autowired
    private EmailUtil emailUtil;
}


‚úÖ No need to write new EmailUtil()
‚úÖ Spring does the creation and injection
--------------------------------------------------------------------
‚úÖ Why do we use @Component? (Interview answer)
‚ÄúWe use @Component to let Spring automatically detect and manage classes as beans.
It enables dependency injection and removes manual object creation.‚Äù


---------------------------------------------------------------------------

#)What is @Bean?
@Bean is used inside a @Configuration class to manually create and register a Spring bean.
It is commonly used for third-party classes or when you need full control over object creation.

------------------------------------------------------------------------------
#)When to use @Bean?
You use @Bean when:
‚úÖ 1. You want to register objects from third-party libraries


@Configuration
public class SecurityConfig {

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();    // used for password hashing
    }
}

How it works internally? (Strong answer)

Spring uses CGLIB proxies to ensure:

Beans inside @Configuration are singleton

@Bean methods are executed only once

Example:
------------------------------------------------------------------
@Configuraiton
‚ÄúWe use @Configuration when we want to define beans manually.
It allows Spring to treat the class as a source of bean definitions.
This is useful for third-party objects, custom initialization, or configuration logic.‚Äù
----------------------------------------------------------------
@Repository
@Repository marks a class as the database layer.
Spring automatically creates it as a bean and handles SQL exceptions for us.‚Äù
@Repository (Database Layer)

‚Äú@Repository is used for classes that interact with the database.
It also converts SQL exceptions into Spring exceptions.‚Äù

Example:
@Repository
public class UserRepository {}


Used for:
‚úÖ Database queries
‚úÖ JDBC, JPA, Hibernate operations
‚úÖ DAO layer


































































